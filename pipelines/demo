- script: |
              # Crear Dockerfile si no existe
              if [ ! -f "Dockerfile" ]; then
                cat <<EOF > Dockerfile
              # Dockerfile para aplicaci√≥n Angular
              # Etapa 1: Build
              FROM node:18-alpine AS build
              WORKDIR /app
              COPY package*.json ./
              RUN npm ci --only=production
              COPY . .
              RUN npm run build --prod
              
              # Etapa 2: Servidor Nginx
              FROM nginx:alpine
              COPY --from=build /app/dist/ /usr/share/nginx/html/
              COPY nginx.conf /etc/nginx/conf.d/default.conf
              EXPOSE 80
              CMD ["nginx", "-g", "daemon off;"]
              EOF
              
                # Crear configuraci√≥n de Nginx
                cat <<EOF > nginx.conf
              server {
                listen 80;
                server_name localhost;
                root /usr/share/nginx/html;
                index index.html;
                
                # Para aplicaciones Angular SPA
                location / {
                  try_files \$uri \$uri/ /index.html;
                }
                
                # Cache est√°tico
                location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
                }
              }
              EOF
              fi
            displayName: 'Crear Dockerfile para Angular'# Azure DevOps Pipeline - CI/CD Pipeline
trigger:
  branches:
    include:
    - main
    - develop

variables:
  # Variables del proyecto
  dockerRepository: 'your-dockerhub-username/dummy-filter'
  dockerfilePath: '**/Dockerfile'
  tag: '$(Build.BuildId)'
  
  # Variables de SonarQube
  sonarQubeEndpoint: 'SonarQube-Connection'
  sonarQubeProjectKey: 'dummy-filter'
  sonarQubeProjectName: 'Dummy Filter'
  
  # Variables de Kubernetes
  kubernetesServiceConnection: 'kubernetes-connection'
  kubernetesNamespace: 'default'
  
pool:
  vmImage: 'ubuntu-latest'

stages:
- stage: SourceCode
  displayName: 'Descargar C√≥digo Fuente'
  jobs:
  - job: Checkout
    displayName: 'Checkout Repository'
    steps:
    - checkout: self
      displayName: 'Descargar c√≥digo del repositorio dummy-filter'
      persistCredentials: true

- stage: CodeAnalysis
  displayName: 'An√°lisis de C√≥digo SonarQube'
  dependsOn: SourceCode
  jobs:
  - job: SonarQubeAnalysis
    displayName: 'An√°lisis SonarQube'
    steps:
    
    - task: SonarQubePrepare@5
      displayName: 'Preparar an√°lisis SonarQube'
      inputs:
        SonarQube: '$(sonarQubeEndpoint)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: '$(sonarQubeProjectKey)'
        cliProjectName: '$(sonarQubeProjectName)'
        cliSources: '.'
        extraProperties: |
          sonar.host.url=http://20.64.146.135:8000
          sonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**,**/*.spec.ts,**/*.log
          sonar.typescript.lcov.reportPaths=coverage/lcov.info
          sonar.sources=src
          sonar.tests=src
    
    - script: |
        echo "Ejecutando an√°lisis de SonarQube..."
        # Aqu√≠ puedes agregar comandos adicionales si es necesario
      displayName: 'Ejecutar comandos pre-an√°lisis'
    
    - task: SonarQubeAnalyze@5
      displayName: 'Ejecutar an√°lisis SonarQube'
      continueOnError: true
    
    - task: SonarQubePublish@5
      displayName: 'Publicar resultados SonarQube'
      inputs:
        pollingTimeoutSec: '300'
      continueOnError: true
    
    # Evaluaci√≥n de Quality Gate
    - script: |
        echo "Verificando Quality Gate..."
        # Obtener el estado del Quality Gate
        QUALITY_GATE_STATUS=$(curl -s -u admin:admin "http://20.64.146.135:8000/api/qualitygates/project_status?projectKey=$(sonarQubeProjectKey)" | jq -r '.projectStatus.status')
        
        echo "Quality Gate Status: $QUALITY_GATE_STATUS"
        
        if [ "$QUALITY_GATE_STATUS" = "OK" ]; then
          echo "##[section]‚úÖ An√°lisis SonarQube EXITOSO - Quality Gate PASSED"
          echo "##vso[task.setvariable variable=sonarResult;isOutput=true]success"
        else
          echo "##[error]‚ùå An√°lisis SonarQube FALLIDO - Quality Gate FAILED"
          echo "##vso[task.setvariable variable=sonarResult;isOutput=true]failed"
          # No fallar el pipeline, solo registrar el error
        fi
      displayName: 'Evaluar Quality Gate'
      name: QualityGateCheck

- stage: Build
  displayName: 'Compilar Aplicaci√≥n'
  dependsOn: CodeAnalysis
  condition: always() # Ejecutar siempre, independientemente del resultado de SonarQube
  jobs:
  - job: BuildApplication
    displayName: 'Compilar y Construir App'
    steps:
    
    - script: |
        echo "üîÑ Iniciando compilaci√≥n..."
        sonar_result='$(stageDependencies.CodeAnalysis.SonarQubeAnalysis.outputs["QualityGateCheck.sonarResult"])'
        
        if [ "$sonar_result" = "success" ]; then
          echo "‚úÖ Continuando con compilaci√≥n - SonarQube exitoso"
        elif [ "$sonar_result" = "failed" ]; then
          echo "‚ö†Ô∏è Continuando con compilaci√≥n - SonarQube fall√≥ pero no bloquea el build"
        else
          echo "‚ÑπÔ∏è Continuando con compilaci√≥n - Estado SonarQube indeterminado"
        fi
      displayName: 'Verificar estado SonarQube'
    
    # Configuraci√≥n para aplicaci√≥n Angular
    - task: NodeTool@0
      displayName: 'Instalar Node.js'
      inputs:
        versionSpec: '18.x'
    
    - task: Npm@1
      displayName: 'Instalar dependencias npm'
      inputs:
        command: 'install'
        workingDir: '.'
    
    - task: Npm@1
      displayName: 'Ejecutar tests unitarios'
      inputs:
        command: 'custom'
        customCommand: 'run test -- --watch=false --browsers=ChromeHeadless'
      continueOnError: true
    
    - task: Npm@1
      displayName: 'Build Angular (Producci√≥n)'
      inputs:
        command: 'custom'
        customCommand: 'run build -- --configuration=production --output-path=dist'
    
    - script: |
        echo "üìÅ Verificando archivos de build..."
        ls -la dist/
        echo "‚úÖ Build de Angular completado exitosamente"
      displayName: 'Verificar build Angular'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publicar artefactos Angular'
      inputs:
        PathtoPublish: 'dist'
        ArtifactName: 'angular-build'
        publishLocation: 'Container'

- stage: Docker
  displayName: 'Crear y Subir Imagen Docker'
  dependsOn: Build
  jobs:
  - job: DockerBuildPush
    displayName: 'Docker Build & Push'
    steps:
    
    - task: Docker@2
      displayName: 'Login a DockerHub'
      inputs:
        command: 'login'
        containerRegistry: 'DockerHub-Connection'
    
    - task: Docker@2
      displayName: 'Construir imagen Docker'
      inputs:
        command: 'build'
        repository: '$(dockerRepository)'
        dockerfile: '$(dockerfilePath)'
        tags: |
          $(tag)
          latest
        arguments: '--no-cache'
    
    - task: Docker@2
      displayName: 'Subir imagen a DockerHub'
      inputs:
        command: 'push'
        repository: '$(dockerRepository)'
        tags: |
          $(tag)
          latest
    
    - script: |
        echo "üê≥ Imagen Docker creada y subida exitosamente:"
        echo "üìç Repositorio: $(dockerRepository)"
        echo "üè∑Ô∏è Tags: $(tag), latest"
        echo "üîó URL: https://hub.docker.com/r/$(dockerRepository)"
      displayName: 'Informaci√≥n de imagen Docker'

- stage: Deploy
  displayName: 'Desplegar en Kubernetes'
  dependsOn: Docker
  jobs:
  - deployment: DeployToKubernetes
    displayName: 'Deploy to K8s'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          
          - script: |
              # Crear manifiesto de Kubernetes
              cat <<EOF > deployment.yaml
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: dummy-filter-app
                namespace: $(kubernetesNamespace)
                labels:
                  app: dummy-filter
              spec:
                replicas: 3
                selector:
                  matchLabels:
                    app: dummy-filter
                template:
                  metadata:
                    labels:
                      app: dummy-filter
                  spec:
                    containers:
                    - name: dummy-filter-angular
                      image: $(dockerRepository):$(tag)
                      ports:
                      - containerPort: 80
                      resources:
                        requests:
                          memory: "64Mi"
                          cpu: "50m"
                        limits:
                          memory: "256Mi"
                          cpu: "200m"
                      livenessProbe:
                        httpGet:
                          path: /
                          port: 80
                        initialDelaySeconds: 30
                        periodSeconds: 10
                      readinessProbe:
                        httpGet:
                          path: /
                          port: 80
                        initialDelaySeconds: 5
                        periodSeconds: 5
              ---
              apiVersion: v1
              kind: Service
              metadata:
                name: dummy-filter-service
                namespace: $(kubernetesNamespace)
              spec:
                selector:
                  app: dummy-filter
                ports:
                - port: 80
                  targetPort: 80
                  protocol: TCP
                type: LoadBalancer
              EOF
            displayName: 'Crear manifiestos Kubernetes'
          
          - task: KubernetesManifest@0
            displayName: 'Desplegar en Kubernetes'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: '$(kubernetesNamespace)'
              manifests: 'deployment.yaml'
          
          - task: Kubernetes@1
            displayName: 'Verificar despliegue'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(kubernetesNamespace)'
              command: 'get'
              arguments: 'pods -l app=dummy-filter'
          
          - script: |
              echo "üöÄ Despliegue completado exitosamente!"
              echo "üìä Resumen del Pipeline:"
              echo "‚îú‚îÄ‚îÄ ‚úÖ C√≥digo descargado del repo 'dummy-filter'"
              echo "‚îú‚îÄ‚îÄ üîç An√°lisis SonarQube ejecutado (IP: 20.64.146.135:8000)"
              echo "‚îú‚îÄ‚îÄ üî® Aplicaci√≥n compilada"
              echo "‚îú‚îÄ‚îÄ üê≥ Imagen Docker creada y subida a DockerHub"
              echo "‚îî‚îÄ‚îÄ ‚ò∏Ô∏è  Aplicaci√≥n desplegada en Kubernetes"
              echo ""
              echo "üîó Para verificar el servicio:"
              echo "kubectl get services -n $(kubernetesNamespace)"
            displayName: 'Resumen de despliegue'

# Tareas de limpieza post-deployment
- stage: PostDeploy
  displayName: 'Post-Deployment'
  dependsOn: Deploy
  condition: always()
  jobs:
  - job: Cleanup
    displayName: 'Limpieza y Notificaciones'
    steps:
    
    - script: |
        echo "üßπ Ejecutando tareas de limpieza..."
        docker system prune -f || echo "Docker cleanup no disponible"
      displayName: 'Limpieza de sistema'
    
    - script: |
        echo "üìß Enviando notificaciones..."
        echo "Pipeline completado: $(Build.BuildNumber)"
        echo "Commit: $(Build.SourceVersion)"
        echo "Branch: $(Build.SourceBranchName)"
        # Aqu√≠ puedes agregar integraciones con Slack, Teams, etc.
      displayName: 'Notificaciones'